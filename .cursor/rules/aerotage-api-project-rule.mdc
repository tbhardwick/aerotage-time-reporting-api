---
description: 
globs: 
alwaysApply: true
---
# Aerotage Time Reporting API - Backend Repository - Cursor Rules

## üèóÔ∏è Repository Architecture Overview

This project uses a **two-repository architecture** to separate concerns:

### üöÄ **aerotage-time-reporting-api** (THIS REPOSITORY)
**Purpose**: Backend AWS serverless infrastructure and API
**Contains**:
- AWS CDK infrastructure code (TypeScript)
- AWS Lambda function implementations
- DynamoDB table definitions and schema
- API Gateway REST API configurations
- AWS Cognito authentication infrastructure
- CloudWatch monitoring and logging setup
- S3 storage bucket configurations
- IAM roles and security policies
- Deployment scripts and infrastructure documentation

### üì± **aerotage_time_reporting_app** (SEPARATE REPOSITORY)
**Purpose**: Frontend Electron desktop application
**Contains**: 
- Electron main process, renderer, and preload scripts
- React/TypeScript frontend code
- UI components, pages, and styling
- State management (React Context)
- Frontend configuration and build tools
- Documentation specific to frontend development

### üîÑ **Repository Interaction Rules**
1. **Backend NEVER contains**: Electron code, React components, frontend styling, UI logic
2. **Frontend NEVER contains**: AWS CDK code, Lambda functions, infrastructure definitions
3. **API Endpoints**: Defined and implemented in this repository, consumed by frontend
4. **Authentication**: Cognito setup in this repo, client integration in frontend repo
5. **Deployment**: This repository infrastructure must be deployed before frontend can connect

## Project Overview
You are developing the **backend infrastructure and API** for the Aerotage Time Reporting Application, a professional time tracking and billing system for Aerotage Design Group, Inc. This is a fully serverless AWS backend using CDK for infrastructure as code.

## Core Technology Stack

### Infrastructure & Deployment
- **Infrastructure as Code**: AWS CDK v2 with TypeScript
- **Compute**: AWS Lambda functions (Node.js 20.x)
- **API**: Amazon API Gateway (REST API)
- **Database**: Amazon DynamoDB (single-table design)
- **Authentication**: Amazon Cognito (User Pools + Identity Pools)
- **Storage**: Amazon S3 (file uploads, exports, invoices)
- **Monitoring**: Amazon CloudWatch (logs, metrics, alarms)
- **Security**: AWS IAM (least privilege access)

### Development Tools
- **Language**: TypeScript (strict mode)
- **Package Manager**: npm
- **Linting**: ESLint with AWS CDK recommended rules
- **Testing**: Jest for unit tests, AWS CDK testing constructs
- **Deployment**: AWS CDK CLI with multiple environments

## File Structure Rules

```
infrastructure/
‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ aerotage-time-api.ts          # CDK app entry point
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ cognito-stack.ts              # Authentication infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ database-stack.ts             # DynamoDB tables and indexes
‚îÇ   ‚îú‚îÄ‚îÄ api-stack.ts                  # API Gateway and Lambda integrations
‚îÇ   ‚îú‚îÄ‚îÄ storage-stack.ts              # S3 buckets and policies
‚îÇ   ‚îî‚îÄ‚îÄ monitoring-stack.ts           # CloudWatch logs, metrics, alarms
‚îú‚îÄ‚îÄ lambda/
‚îÇ   ‚îú‚îÄ‚îÄ time-entries/                 # Time entry CRUD operations
‚îÇ   ‚îú‚îÄ‚îÄ projects/                     # Project management
‚îÇ   ‚îú‚îÄ‚îÄ clients/                      # Client management
‚îÇ   ‚îú‚îÄ‚îÄ users/                        # User management
‚îÇ   ‚îú‚îÄ‚îÄ teams/                        # Team and role management
‚îÇ   ‚îú‚îÄ‚îÄ reports/                      # Reporting and analytics
‚îÇ   ‚îî‚îÄ‚îÄ invoices/                     # Invoice generation and management
‚îú‚îÄ‚îÄ test/                             # CDK and Lambda unit tests
‚îú‚îÄ‚îÄ docs/                             # API documentation
‚îú‚îÄ‚îÄ cdk.json                          # CDK configuration
‚îú‚îÄ‚îÄ package.json                      # Dependencies and scripts
‚îî‚îÄ‚îÄ tsconfig.json                     # TypeScript configuration

# IMPORTANT: NO src/renderer/, public/, or Electron-related files
# Frontend code is maintained in aerotage_time_reporting_app repo
```

## AWS CDK Development Rules

### Stack Organization
1. **Single Responsibility**: Each stack has one clear purpose
2. **Environment Isolation**: Separate stacks for dev/staging/prod
3. **Resource Naming**: Use consistent naming conventions with environment prefixes
4. **Cross-Stack References**: Use CloudFormation exports for shared resources
5. **Stack Dependencies**: Explicitly define stack dependencies in CDK app

### CDK Best Practices
1. **Constructs**: Create reusable constructs for common patterns
2. **Props Interfaces**: Define TypeScript interfaces for all stack props
3. **Validation**: Implement prop validation in stack constructors
4. **Tagging**: Apply consistent tags to all resources for cost tracking
5. **Removal Policy**: Explicitly set removal policies for data resources

### Infrastructure Configuration
```typescript
// Example stack structure
export class CognitoStack extends Stack {
  public readonly userPool: cognito.UserPool;
  public readonly userPoolClient: cognito.UserPoolClient;
  public readonly identityPool: cognito.CfnIdentityPool;

  constructor(scope: Construct, id: string, props: CognitoStackProps) {
    super(scope, id, props);
    
    // Implementation with proper error handling
    // Always include IAM roles for Identity Pool
    // Use least privilege access principles
  }
}
```

## Lambda Function Development Rules

### Function Structure
1. **Single Purpose**: Each Lambda function has one specific responsibility
2. **Handler Pattern**: Use consistent handler pattern across all functions
3. **Error Handling**: Implement comprehensive error handling and logging
4. **Input Validation**: Validate all inputs using TypeScript types
5. **Response Format**: Use consistent API response format

### Lambda Best Practices
1. **Runtime**: Use Node.js 20.x for all functions
2. **Memory**: Right-size memory allocation (128MB-3008MB)
3. **Timeout**: Set appropriate timeouts (max 29 seconds for API Gateway)
4. **Environment Variables**: Use for configuration, never for secrets
5. **Dependency Management**: Keep dependencies minimal and up-to-date

### Function Template
```typescript
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';

export const handler = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
  try {
    // Input validation
    // Business logic
    // Return success response
    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({ success: true, data: result })
    };
  } catch (error) {
    console.error('Function error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' })
    };
  }
};
```

## Database Design Rules

### DynamoDB Best Practices
1. **Single Table Design**: Use one table with GSIs for different access patterns
2. **Partition Key Strategy**: Design for even distribution of data
3. **Sort Key Patterns**: Support multiple query patterns with sort keys
4. **GSI Design**: Create GSIs for additional access patterns
5. **Item Size**: Keep items under 400KB limit

### Data Access Patterns
1. **Get User by ID**: PK=USER#userId
2. **List Projects by Client**: GSI on clientId
3. **Get Time Entries by Date Range**: Sort key with date prefixes
4. **Report Queries**: Design GSIs for common reporting needs
5. **Audit Trail**: Include createdAt, updatedAt, and user info

## API Design Rules

### REST API Conventions
1. **HTTP Methods**: Use appropriate HTTP verbs (GET, POST, PUT, DELETE)
2. **Status Codes**: Return correct HTTP status codes
3. **URL Structure**: Use resource-based URLs (/api/v1/time-entries)
4. **Pagination**: Implement cursor-based pagination for lists
5. **Rate Limiting**: Apply appropriate throttling rules

### Request/Response Format
1. **Content Type**: Use application/json for all APIs
2. **Error Format**: Consistent error response structure
3. **Timestamps**: Use ISO 8601 format for all dates
4. **Field Naming**: Use camelCase for consistency with frontend
5. **Validation**: Validate all inputs and return meaningful error messages

## Security Implementation Rules

### Authentication & Authorization
1. **JWT Tokens**: Use Cognito JWT tokens for API authentication
2. **Token Validation**: Validate tokens in Lambda authorizers
3. **Role-Based Access**: Implement RBAC using Cognito groups
4. **Least Privilege**: Grant minimum required permissions
5. **Token Refresh**: Implement proper token refresh flows

### Data Protection
1. **Encryption**: Enable encryption at rest for all data stores
2. **Transport Security**: Use HTTPS/TLS for all communications
3. **Input Sanitization**: Sanitize all user inputs
4. **SQL Injection Prevention**: Use parameterized queries (DynamoDB SDK)
5. **Secret Management**: Use AWS Secrets Manager for sensitive data

## Deployment & Environment Management

### Environment Strategy
1. **Development**: For active feature development and testing
2. **Staging**: For pre-production testing and QA
3. **Production**: For live customer usage
4. **Feature Branches**: Deploy to ephemeral environments for testing

### Deployment Process
```bash
# Development environment
npm run deploy:dev

# Staging environment  
npm run deploy:staging

# Production environment
npm run deploy:prod

# Destroy environment (dev/staging only)
npm run destroy:dev
```

### Configuration Management
1. **Environment Variables**: Use CDK context for environment-specific config
2. **Feature Flags**: Implement feature toggles for gradual rollouts
3. **Version Tagging**: Tag all resources with version information
4. **Rollback Strategy**: Maintain ability to rollback deployments
5. **Database Migrations**: Handle schema changes carefully

## Monitoring & Observability

### CloudWatch Implementation
1. **Structured Logging**: Use JSON format for all log messages
2. **Log Levels**: Implement appropriate log levels (ERROR, WARN, INFO, DEBUG)
3. **Correlation IDs**: Include request correlation IDs in all logs
4. **Metrics**: Create custom metrics for business KPIs
5. **Alarms**: Set up alarms for error rates, latency, and costs

### Performance Monitoring
1. **API Response Times**: Monitor and alert on slow responses
2. **Lambda Duration**: Track function execution times
3. **DynamoDB Metrics**: Monitor read/write capacity utilization
4. **Error Rates**: Track and alert on error rate increases
5. **Cost Monitoring**: Set up billing alerts and cost anomaly detection

## Testing Requirements

### Unit Testing
1. **CDK Constructs**: Test all custom constructs and stacks
2. **Lambda Functions**: Unit test all business logic
3. **Test Coverage**: Maintain minimum 80% code coverage
4. **Mocking**: Mock AWS services using aws-sdk-client-mock
5. **Test Data**: Use factories for generating test data

### Integration Testing
1. **API Testing**: Test complete API workflows
2. **Database Testing**: Test DynamoDB operations with local DynamoDB
3. **Authentication**: Test Cognito integration flows
4. **Error Scenarios**: Test error handling and edge cases
5. **Performance**: Load test APIs under expected traffic

## Development Workflow

### Git Practices
1. **Conventional Commits**: Use conventional commit format
2. **Feature Branches**: Create branches for each feature/fix
3. **Pull Requests**: Require code review for all changes
4. **Deployment Tags**: Tag deployments with version numbers
5. **Hotfix Process**: Maintain hotfix workflow for production issues

### Code Quality
1. **TypeScript**: Use strict TypeScript configuration
2. **ESLint**: Follow AWS CDK ESLint recommended rules
3. **Prettier**: Consistent code formatting
4. **Pre-commit Hooks**: Run linting and tests before commits
5. **Documentation**: Document all public APIs and complex logic

## Prohibited Practices

### Never Do
- Store secrets or credentials in code or environment variables
- Use deprecated AWS services or APIs
- Implement custom authentication instead of using Cognito
- Create overly broad IAM permissions
- Deploy directly to production without testing
- Use console.log in production (use proper logging)
- Hardcode environment-specific values
- Skip input validation for Lambda functions
- Create circular dependencies between stacks
- Use deprecated CDK constructs
- **Add frontend code (React, Electron, UI) to this repository** ‚ùå
- **Store frontend dependencies in package.json** ‚ùå
- **Implement UI logic in Lambda functions** ‚ùå
- **Include build tools for frontend applications** ‚ùå

### Always Do
- Follow AWS Well-Architected Framework principles
- Use CDK best practices and design patterns
- Implement proper error handling and logging
- Test infrastructure changes in non-production environments
- Use least privilege access for all IAM roles
- Monitor resource costs and optimize regularly
- Document API changes and breaking changes
- Version APIs and maintain backward compatibility
- **Keep infrastructure and API logic separate from frontend** ‚úÖ
- **Coordinate API changes with frontend team** ‚úÖ
- **Deploy backend infrastructure before frontend testing** ‚úÖ
- **Maintain API documentation for frontend consumption** ‚úÖ

## API Documentation

### OpenAPI Specification
1. **API Docs**: Maintain OpenAPI 3.0 specification
2. **Endpoint Documentation**: Document all endpoints with examples
3. **Schema Definitions**: Define request/response schemas
4. **Authentication**: Document authentication requirements
5. **Error Responses**: Document all possible error responses

### Consumer Communication
1. **API Changes**: Communicate breaking changes to frontend team
2. **Version Management**: Use semantic versioning for API changes
3. **Migration Guides**: Provide migration guides for breaking changes
4. **Changelog**: Maintain detailed changelog for all releases
5. **Testing Support**: Provide testing endpoints and data for frontend development

## Cost Optimization

### Resource Management
1. **Right-sizing**: Regularly review and optimize resource allocation
2. **Reserved Capacity**: Use reserved capacity for predictable workloads
3. **Lifecycle Policies**: Implement S3 lifecycle policies for cost optimization
4. **Monitoring**: Set up cost alerts and anomaly detection
5. **Resource Cleanup**: Regularly clean up unused resources

### Performance Optimization
1. **Lambda Performance**: Optimize function memory and timeout settings
2. **DynamoDB Optimization**: Monitor and optimize read/write capacity
3. **API Caching**: Implement appropriate caching strategies
4. **Connection Pooling**: Reuse database connections in Lambda functions
5. **Bundle Size**: Minimize Lambda deployment package sizes

Remember: This repository is focused exclusively on backend infrastructure and API development. All frontend code, UI components, and Electron application logic belongs in the separate `aerotage_time_reporting_app` repository. The goal is clean separation of concerns while maintaining a robust, scalable, and secure backend system.
