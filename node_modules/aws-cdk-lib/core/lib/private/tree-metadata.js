"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TreeMetadata=void 0,exports.isSubtreeReference=isSubtreeReference;var fs=()=>{var tmp=require("fs");return fs=()=>tmp,tmp},path=()=>{var tmp=require("path");return path=()=>tmp,tmp},constructs_1=()=>{var tmp=require("constructs");return constructs_1=()=>tmp,tmp},runtime_info_1=()=>{var tmp=require("./runtime-info");return runtime_info_1=()=>tmp,tmp},cloud_assembly_schema_1=()=>{var tmp=require("../../../cloud-assembly-schema");return cloud_assembly_schema_1=()=>tmp,tmp},annotations_1=()=>{var tmp=require("../annotations");return annotations_1=()=>tmp,tmp},stack_1=()=>{var tmp=require("../stack");return stack_1=()=>tmp,tmp},tree_1=()=>{var tmp=require("../tree");return tree_1=()=>tmp,tmp},construct_iteration_1=()=>{var tmp=require("./construct-iteration");return construct_iteration_1=()=>tmp,tmp};const FILE_PATH="tree.json";class TreeMetadata extends constructs_1().Construct{constructor(scope){super(scope,"Tree")}_synthesizeTree(session){const maxNodesPerTree=this.node.tryGetContext("@aws-cdk/core.TreeMetadata:maxNodes"),builder=session.assembly,writer=new FragmentedTreeWriter(builder.outdir,FILE_PATH,{maxNodesPerTree});for(const{construct,parent}of(0,construct_iteration_1().iterateBfs)(this.node.root)){const node={id:construct.node.id||"App",path:construct.node.path,constructInfo:(0,runtime_info_1().constructInfoFromConstruct)(construct)};try{node.attributes=this.synthAttributes(construct)}catch(e){annotations_1().Annotations.of(this).addWarningV2(`@aws-cdk/core:failedToRenderTreeMetadata-${construct.node.id}`,`Failed to render tree metadata for node [${construct.node.id}]. Reason: ${e}`)}writer.addNode(construct,parent,node)}const rootFilename=writer.writeForest();builder.addArtifact("Tree",{type:cloud_assembly_schema_1().ArtifactType.CDK_TREE,properties:{file:rootFilename}})}synthAttributes(construct){function canInspect(inspectable){return inspectable.inspect!==void 0}const inspector=new(tree_1()).TreeInspector;if(canInspect(construct))return construct.inspect(inspector),stack_1().Stack.of(construct).resolve(inspector.attributes)}}exports.TreeMetadata=TreeMetadata;class FragmentedTreeWriter{constructor(outdir,rootFilename,options){this.outdir=outdir,this.rootFilename=rootFilename,this.forest=new Array,this.constructMap=new Map,this.subtreeRoots=new Map,this.parent=new Map,this.subtreeCtr=1,this.maxNodes=options?.maxNodesPerTree??5e5}writeForest(){for(const tree of this.forest){const treeFile={version:"tree-0.1",tree:tree.root};fs().writeFileSync(path().join(this.outdir,tree.filename),JSON.stringify(treeFile),{encoding:"utf-8"})}return this.rootFilename}addNode(construct,parent,node){if(parent===void 0){if(this.forest.length>0)throw new Error("Can only add exactly one node without a parent");this.addNewTree(node,this.rootFilename)}else{const parentNode=this.constructMap.get(parent);if(!parentNode)return;this.addToExistingTree(node,parentNode)}this.constructMap.set(construct,node)}addNewTree(root,filename){const tree={root,filename,nodes:nodeCount(root)};return this.forest.push(tree),this.subtreeRoots.set(root,tree),tree}addToExistingTree(node,parent){let tree=this.treeForNode(parent);if(this.isTreeFull(tree)){const grandParent=this.parent.get(parent);if(!grandParent)throw new Error(`Could not find parent of ${JSON.stringify(parent)}`);tree=this.addNewTree(parent,`tree-${this.subtreeCtr++}.json`),setChild(grandParent,{id:parent.id,path:parent.path,fileName:tree.filename}),this.subtreeRoots.set(parent,tree)}setChild(parent,node),this.parent.set(node,parent),tree.nodes+=1}isTreeFull(t){return t.nodes>=this.maxNodes}treeForNode(node){const tried=new Array;let cur=node;tried.push(cur.path);let tree=this.subtreeRoots.get(cur);for(;!tree&&cur;)cur=this.parent.get(cur),tried.push(cur?.path),tree=cur&&this.subtreeRoots.get(cur);if(tree)return tree;throw new Error(`Could not find tree for node: ${JSON.stringify(node)}, tried ${tried}, ${Array.from(this.subtreeRoots).map(([k,v])=>`${k.path} => ${v.filename}`)}`)}}function nodeCount(root){let ret=0;return recurse(root),ret;function recurse(x){ret+=1;for(const child of Object.values(x.children??{}))recurse(child)}}function setChild(parent,node){parent.children||(parent.children={}),parent.children[node.id]=node}function isSubtreeReference(x){return!!x.fileName}
